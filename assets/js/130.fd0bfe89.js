(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{468:function(t,_,r){"use strict";r.r(_);var a=r(7),v=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"一、接口隔离模式之proxy-代理模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、接口隔离模式之proxy-代理模式"}},[t._v("#")]),t._v(" 一、接口隔离模式之Proxy（代理模式）")]),t._v(" "),_("p",[t._v("在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来相互紧密关联的接口是一种常见的解决方案")]),t._v(" "),_("h4",{attrs:{id:"_1-动机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-动机"}},[t._v("#")]),t._v(" 1.动机")]),t._v(" "),_("p",[t._v("在面向对象系统中，有些对象由于某些原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。")]),t._v(" "),_("p",[t._v("如何在不失去透明操作（一致性）对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式")]),t._v(" "),_("p",[t._v("Q：中间件就是这么来的吗？")]),t._v(" "),_("h4",{attrs:{id:"_2-模式定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-模式定义"}},[t._v("#")]),t._v(" 2.模式定义")]),t._v(" "),_("p",[t._v("为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问")]),t._v(" "),_("h4",{attrs:{id:"_3-要点总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-要点总结"}},[t._v("#")]),t._v(" 3.要点总结")]),t._v(" "),_("p",[t._v("“增加一层间接层”是软件系统中对许多复杂问题的一种常见解决方法。在面向对象对象系统中，直接使用 某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。")]),t._v(" "),_("p",[t._v("具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在框架层次对对象做proxy")]),t._v(" "),_("p",[t._v("proxy并不一定要求保持接口完整的一致性，只要能实现间接控制，有时候损及一些透明性也是可以接受的。")]),t._v(" "),_("h3",{attrs:{id:"二、散装知识点、问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、散装知识点、问题"}},[t._v("#")]),t._v(" 二、散装知识点、问题")]),t._v(" "),_("p",[t._v("1.代理模式有时又专门的工具来实现。原理简单但是实现起来复杂")]),t._v(" "),_("p",[t._v("2.分布式系统大量的使用代理模式")]),t._v(" "),_("p",[t._v("3.代理本质是增加间接层，透明的对系统进行更新迭代")]),t._v(" "),_("p",[t._v("Q：是不是相当于灰度升级？灰度升级是怎么实现的？")])])}),[],!1,null,null,null);_.default=v.exports}}]);