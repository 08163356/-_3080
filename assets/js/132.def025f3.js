(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{469:function(t,v,o){"use strict";o.r(v);var _=o(7),r=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"一、对象创建模式之prototype-原型模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、对象创建模式之prototype-原型模式"}},[t._v("#")]),t._v(" 一、对象创建模式之Prototype（原型模式）")]),t._v(" "),v("p",[t._v("（用的相对较少，工厂方法和抽象工厂用的比较多）")]),t._v(" "),v("p",[v("strong",[t._v("动机")])]),t._v(" "),v("p",[t._v("在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。")]),t._v(" "),v("p",[t._v("如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出这些易变的对象，从而使得“依赖这些易变对象的客户程序”不随着需求的改变而改变")]),t._v(" "),v("p",[v("strong",[t._v("模式定义")])]),t._v(" "),v("p",[t._v("使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象")]),t._v(" "),v("p",[v("strong",[t._v("什么时候使用原型模型")])]),t._v(" "),v("p",[t._v("用工厂方法能用简单的步骤把对象创建出来，还是需要考虑对象复杂的中间状态，如果需要考虑对象复杂的中间状态那么就是用原型模式。（开发中遇到的情况比较少）")]),t._v(" "),v("p",[v("strong",[t._v("要点总结")])]),t._v(" "),v("ul",[v("li",[t._v('Prototype模式同样用于隔离类对象的使用者和具体类型（易变类) 之间的耦合关系，它同样要求这些"易变类”拥有“稳定的接口”。')]),t._v(" "),v("li",[t._v("Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。")]),t._v(" "),v("li",[t._v("Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。")])]),t._v(" "),v("h3",{attrs:{id:"二、散装知识点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、散装知识点"}},[t._v("#")]),t._v(" "),v("strong",[t._v("二、散装知识点")])]),t._v(" "),v("p",[t._v("1.java中clone（）实际上的实现就是序列化和反序列化。C++要实现序列化反序列化很麻烦，拷贝构造函数是他的标配。")])])}),[],!1,null,null,null);v.default=r.exports}}]);