(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{463:function(a,t,_){"use strict";_.r(t);var v=_(7),e=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"一、接口隔离模式之facade-门面模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、接口隔离模式之facade-门面模式"}},[a._v("#")]),a._v(" 一、接口隔离模式之Facade（门面模式）")]),a._v(" "),t("p",[a._v("再组件构建过程中，某些接口之间直接依赖常常会带来很多问题，甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来相互紧密关联的接口是一种常见的解决方案。")]),a._v(" "),t("p",[a._v("就相当于中间商")]),a._v(" "),t("p",[a._v("系统间的耦合复杂度")]),a._v(" "),t("p",[a._v("（）")]),a._v(" "),t("h4",{attrs:{id:"_1-动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-动机"}},[a._v("#")]),a._v(" 1.动机")]),a._v(" "),t("p",[a._v("上述A方案的问题在于组件的客户和组件中各种复杂子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临着很多变化的挑战。")]),a._v(" "),t("p",[a._v("如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间依赖相互解耦？")]),a._v(" "),t("h4",{attrs:{id:"_2-模式定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-模式定义"}},[a._v("#")]),a._v(" 2.模式定义")]),a._v(" "),t("p",[a._v("为子系统中的一组接口提供一个一致（稳定）的界面。facede模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。")]),a._v(" "),t("h4",{attrs:{id:"_3-要点总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-要点总结"}},[a._v("#")]),a._v(" 3.要点总结")]),a._v(" "),t("ul",[t("li",[a._v("从系统程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果--内部子系统的任何变化都不会影响到Facade接口的变化。")]),a._v(" "),t("li",[a._v("Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式")]),a._v(" "),t("li",[a._v("Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。")])]),a._v(" "),t("h3",{attrs:{id:"二、散装问题、知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、散装问题、知识点"}},[a._v("#")]),a._v(" 二、散装问题、知识点")]),a._v(" "),t("p",[a._v("1.软件和硬件之间可以抽离出操作系统，软件和操作系统之间又可以抽离出中间件，JVM")]),a._v(" "),t("p",[a._v("2.依赖倒置也是间接思想的一种体现。")]),a._v(" "),t("p",[a._v("3.Facade实现子系统外部和内部的解耦")])])}),[],!1,null,null,null);t.default=e.exports}}]);