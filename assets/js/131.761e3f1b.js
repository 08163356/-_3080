(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{467:function(t,v,_){"use strict";_.r(v);var n=_(7),e=Object(n.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"一、对象性能模式之singleton-单例模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、对象性能模式之singleton-单例模式"}},[t._v("#")]),t._v(" 一、对象性能模式之Singleton（单例模式）")]),t._v(" "),v("p",[t._v("面向对象很好地解决了“抽象”的问题，但是不可避免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。")]),t._v(" "),v("p",[v("strong",[t._v("1.动机")])]),t._v(" "),v("ul",[v("li",[t._v("在软件系统中，经常有这样一些特殊的类，必须保证他们在系统中只存在一个实例，才能确保他们的逻辑正确性、以及良好的效率（比如任务管理器）")]),t._v(" "),v("li",[t._v("如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？")]),t._v(" "),v("li",[t._v("这应该是类设计者的责任，而不是使用者的责任。")])]),t._v(" "),v("p",[v("strong",[t._v("2.模式定义")])]),t._v(" "),v("p",[t._v("证一个类仅有一个实例，并提供一个该实例的全局访问点。")]),t._v(" "),v("p",[v("strong",[t._v("3.要点总结")])]),t._v(" "),v("p",[t._v("Singleton模式中的实例构造器可以设置为protected以允许子类派生")]),t._v(" "),v("p",[t._v("Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例与Singleton模式的初衷违背")]),t._v(" "),v("p",[t._v("如何实现多线程环境下的Singleton？注意对双检查锁的正确实现。")]),t._v(" "),v("h3",{attrs:{id:"二、散装知识点、问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、散装知识点、问题"}},[t._v("#")]),t._v(" 二、散装知识点、问题")]),t._v(" "),v("p",[t._v("1.用户不会按照你所期望的方式使用产品")]),t._v(" "),v("p",[t._v("2.如果自己不写构造器，系统自动生成缺省和拷贝构造器")]),t._v(" "),v("p",[t._v("3.在编译器层面可能出现reorder问题。new一个对象过程应该是分配内存，再执行构造器，再赋值。而reorder可能是分配内存，直接赋值，再执行构造器（编译器做的事情）。java以及C++11版本之后加上volatile可以解决这个问题")]),t._v(" "),v("p",[t._v("4.双检查锁容易出问题")])])}),[],!1,null,null,null);v.default=e.exports}}]);