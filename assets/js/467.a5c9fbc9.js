(window.webpackJsonp=window.webpackJsonp||[]).push([[467],{803:function(_,v,t){"use strict";t.r(v);var s=t(7),e=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("本文来自：https://mp.weixin.qq.com/s/xUOsYIbKW2MGe5JnR-i6dw 作者: Think")]),_._v(" "),v("p",[_._v("本文教你8种逻辑判断写法，包括：")]),_._v(" "),v("ol",[v("li",[_._v("if/else")]),_._v(" "),v("li",[_._v("switch")]),_._v(" "),v("li",[_._v("一元判断时：存到Object里")]),_._v(" "),v("li",[_._v("一元判断时：存到Map里")]),_._v(" "),v("li",[_._v("多元判断时：将condition拼接成字符串存到Object里")]),_._v(" "),v("li",[_._v("多元判断时：将condition拼接成字符串存到Map里")]),_._v(" "),v("li",[_._v("多元判断时：将condition存为Object存到Map里")]),_._v(" "),v("li",[_._v("多元判断时：将condition写作正则存到Map里")])]),_._v(" "),v("h5",{attrs:{id:"愿你未来的人生里-不只是有if-else-switch。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#愿你未来的人生里-不只是有if-else-switch。"}},[_._v("#")]),_._v(" 愿你未来的人生里，不只是有if/else/switch。")]),_._v(" "),v("p",[_._v("先看一段代码")]),_._v(" "),v("blockquote",[v("p",[_._v("/**")]),_._v(" "),v("p",[_._v("* 按钮点击事件")]),_._v(" "),v("p",[_._v("* @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消")]),_._v(" "),v("p",[_._v("*/")]),_._v(" "),v("p",[_._v("const onButtonClick = (status) => {")]),_._v(" "),v("p",[_._v("if (status == 1) {")]),_._v(" "),v("p",[_._v("sendLog('processing') jumpTo('IndexPage')")]),_._v(" "),v("p",[_._v("} else if (status == 2) {")]),_._v(" "),v("p",[_._v("sendLog('fail') jumpTo('FailPage')")]),_._v(" "),v("p",[_._v("} else if (status == 3) {")]),_._v(" "),v("p",[_._v("sendLog('fail') jumpTo('FailPage')")]),_._v(" "),v("p",[_._v("} else if (status == 4) {")]),_._v(" "),v("p",[_._v("sendLog('success') jumpTo('SuccessPage')")]),_._v(" "),v("p",[_._v("} else if (status == 5) {")]),_._v(" "),v("p",[_._v("sendLog('cancel') jumpTo('CancelPage')")]),_._v(" "),v("p",[_._v("} else {")]),_._v(" "),v("p",[_._v("sendLog('other') jumpTo('Index')")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：")]),_._v(" "),v("blockquote",[v("p",[_._v("/**")]),_._v(" "),v("p",[_._v("* 按钮点击事件")]),_._v(" "),v("p",[_._v("* @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消")]),_._v(" "),v("p",[_._v("*/")]),_._v(" "),v("p",[_._v("const onButtonClick = (status) => {")]),_._v(" "),v("p",[_._v("switch (status) {")]),_._v(" "),v("p",[_._v("case 1:")]),_._v(" "),v("p",[_._v("sendLog('processing')")]),_._v(" "),v("p",[_._v("jumpTo('IndexPage')")]),_._v(" "),v("p",[_._v("break")]),_._v(" "),v("p",[_._v("case 2:")]),_._v(" "),v("p",[_._v("case 3:")]),_._v(" "),v("p",[_._v("sendLog('fail')")]),_._v(" "),v("p",[_._v("jumpTo('FailPage')")]),_._v(" "),v("p",[_._v("break")]),_._v(" "),v("p",[_._v("case 4:")]),_._v(" "),v("p",[_._v("sendLog('success')")]),_._v(" "),v("p",[_._v("jumpTo('SuccessPage')")]),_._v(" "),v("p",[_._v("break")]),_._v(" "),v("p",[_._v("case 5:")]),_._v(" "),v("p",[_._v("sendLog('cancel')")]),_._v(" "),v("p",[_._v("jumpTo('CancelPage')")]),_._v(" "),v("p",[_._v("break")]),_._v(" "),v("p",[_._v("default:")]),_._v(" "),v("p",[_._v("sendLog('other')")]),_._v(" "),v("p",[_._v("jumpTo('Index')")]),_._v(" "),v("p",[_._v("break")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。")]),_._v(" "),v("p",[_._v("这时有同学会说，还有更简单的写法：")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = {")]),_._v(" "),v("p",[_._v("'1': ['processing', 'IndexPage'],")]),_._v(" "),v("p",[_._v("'2': ['fail', 'FailPage'],")]),_._v(" "),v("p",[_._v("'3': ['fail', 'FailPage'],")]),_._v(" "),v("p",[_._v("'4': ['success', 'SuccessPage'],")]),_._v(" "),v("p",[_._v("'5': ['cancel', 'CancelPage'],")]),_._v(" "),v("p",[_._v("'default': ['other', 'Index'],")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("/**")]),_._v(" "),v("p",[_._v("* 按钮点击事件")]),_._v(" "),v("p",[_._v("* @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消")]),_._v(" "),v("p",[_._v("*/")]),_._v(" "),v("p",[_._v("const onButtonClick = (status) => {")]),_._v(" "),v("p",[_._v("let action = actions[status] || actions['default'],")]),_._v(" "),v("p",[_._v("logName = action[0],")]),_._v(" "),v("p",[_._v("pageName = action[1]")]),_._v(" "),v("p",[_._v("sendLog(logName)")]),_._v(" "),v("p",[_._v("jumpTo(pageName)")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。")]),_._v(" "),v("p",[_._v("是不是还有其他写法呢？有的：")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = new Map([")]),_._v(" "),v("p",[_._v("[1, ['processing', 'IndexPage']],")]),_._v(" "),v("p",[_._v("[2, ['fail', 'FailPage']],")]),_._v(" "),v("p",[_._v("[3, ['fail', 'FailPage']],")]),_._v(" "),v("p",[_._v("[4, ['success', 'SuccessPage']],")]),_._v(" "),v("p",[_._v("[5, ['cancel', 'CancelPage']],")]),_._v(" "),v("p",[_._v("['default', ['other', 'Index']]")]),_._v(" "),v("p",[_._v("])")]),_._v(" "),v("p",[_._v("/**")]),_._v(" "),v("p",[_._v("* 按钮点击事件")]),_._v(" "),v("p",[_._v("* @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消")]),_._v(" "),v("p",[_._v("*/")]),_._v(" "),v("p",[_._v("const onButtonClick = (status) => {")]),_._v(" "),v("p",[_._v("let action = actions.get(status) || actions.get('default')")]),_._v(" "),v("p",[_._v("sendLog(action[0])")]),_._v(" "),v("p",[_._v("jumpTo(action[1])")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？")]),_._v(" "),v("ol",[v("li",[_._v('一个对象通常都有自己的原型，所以一个对象总有一个"prototype"键。')]),_._v(" "),v("li",[_._v("一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。")]),_._v(" "),v("li",[_._v("你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。")])]),_._v(" "),v("p",[_._v("我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份：")]),_._v(" "),v("blockquote",[v("p",[_._v("/**")]),_._v(" "),v("p",[_._v("* 按钮点击事件")]),_._v(" "),v("p",[_._v("* @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团")]),_._v(" "),v("p",[_._v("* @param {string} identity 身份标识：guest客态 master主态")]),_._v(" "),v("p",[_._v("*/")]),_._v(" "),v("p",[_._v("const onButtonClick = (status, identity) => {")]),_._v(" "),v("p",[_._v("if (identity == 'guest') {")]),_._v(" "),v("p",[_._v("if (status == 1) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else if (status == 2) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else if (status == 3) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else if (status == 4) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else if (status == 5) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("} else if (identity == 'master') {")]),_._v(" "),v("p",[_._v("if (status == 1) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else if (status == 2) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else if (status == 3) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else if (status == 4) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else if (status == 5) {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("} else {")]),_._v(" "),v("p",[_._v("//do sth")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。")]),_._v(" "),v("p",[_._v("原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。")]),_._v(" "),v("p",[_._v("从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = new Map([")]),_._v(" "),v("p",[_._v("['guest_1', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['guest_2', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['guest_3', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['guest_4', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['guest_5', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['master_1', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['master_2', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['master_3', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['master_4', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['master_5', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("['default', () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("])")]),_._v(" "),v("p",[_._v("/**")]),_._v(" "),v("p",[_._v("* 按钮点击事件")]),_._v(" "),v("p",[_._v("* @param {string} identity 身份标识：guest客态 master主态")]),_._v(" "),v("p",[_._v("* @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团")]),_._v(" "),v("p",[_._v("*/")]),_._v(" "),v("p",[_._v("const onButtonClick = (identity, status) => {")]),_._v(" "),v("p",[_._v("let action = actions.get("),v("code",[_._v("${identity}_${status}")]),_._v(") || actions.get('default')")]),_._v(" "),v("p",[_._v("action.call(this)")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。")]),_._v(" "),v("p",[_._v("当然上述代码如果用Object对象来实现也是类似的：")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = {")]),_._v(" "),v("p",[_._v("'guest_1': () => { /"),v("em",[_._v("do sth")]),_._v("/ },")]),_._v(" "),v("p",[_._v("'guest_2': () => { /"),v("em",[_._v("do sth")]),_._v("/ },")]),_._v(" "),v("p",[_._v("//....")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("const onButtonClick = (identity, status) => {")]),_._v(" "),v("p",[_._v("let action = actions["),v("code",[_._v("${identity}_${status}")]),_._v("] || actions['default']")]),_._v(" "),v("p",[_._v("action.call(this)")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = new Map([")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 1")]),_._v(" "),v("p",[_._v("}, () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 2")]),_._v(" "),v("p",[_._v("}, () => { /"),v("em",[_._v("do sth")]),_._v("/ }],")]),_._v(" "),v("p",[_._v("//...")]),_._v(" "),v("p",[_._v("])")]),_._v(" "),v("p",[_._v("const onButtonClick = (identity, status) => {")]),_._v(" "),v("p",[_._v("let action = [...actions].filter(([key, value]) => (key.identity == identity && key.status == status))")]),_._v(" "),v("p",[_._v("action.forEach(([key, value]) => value.call(this))")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("是不是又高级了一点点？")]),_._v(" "),v("p",[_._v("这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。")]),_._v(" "),v("p",[_._v("我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = new Map([")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 1")]),_._v(" "),v("p",[_._v("}, () => { /* functionA */ }],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 2")]),_._v(" "),v("p",[_._v("}, () => { /* functionA */ }],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 3")]),_._v(" "),v("p",[_._v("}, () => { /* functionA */ }],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 4")]),_._v(" "),v("p",[_._v("}, () => { /* functionA */ }],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 5")]),_._v(" "),v("p",[_._v("}, () => { /* functionB */ }],")]),_._v(" "),v("p",[_._v("//...")]),_._v(" "),v("p",[_._v("])")])]),_._v(" "),v("p",[_._v("好一点的写法是将处理逻辑函数进行缓存：")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = () => {")]),_._v(" "),v("p",[_._v("const functionA = () => { /"),v("em",[_._v("do sth")]),_._v("/ }")]),_._v(" "),v("p",[_._v("const functionB = () => { /"),v("em",[_._v("do sth")]),_._v("/ }")]),_._v(" "),v("p",[_._v("return new Map([")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 1")]),_._v(" "),v("p",[_._v("}, functionA],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 2")]),_._v(" "),v("p",[_._v("}, functionA],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 3")]),_._v(" "),v("p",[_._v("}, functionA],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 4")]),_._v(" "),v("p",[_._v("}, functionA],")]),_._v(" "),v("p",[_._v("[{")]),_._v(" "),v("p",[_._v("identity: 'guest',")]),_._v(" "),v("p",[_._v("status: 5")]),_._v(" "),v("p",[_._v("}, functionB],")]),_._v(" "),v("p",[_._v("//...")]),_._v(" "),v("p",[_._v("])")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("const onButtonClick = (identity, status) => {")]),_._v(" "),v("p",[_._v("let action = [...actions()].filter(([key, value]) => (key.identity == identity && key.status == status))")]),_._v(" "),v("p",[_._v("action.forEach(([key, value]) => value.call(this))")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现:")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = () => {")]),_._v(" "),v("p",[_._v("const functionA = () => { /"),v("em",[_._v("do sth")]),_._v("/ }")]),_._v(" "),v("p",[_._v("const functionB = () => { /"),v("em",[_._v("do sth")]),_._v("/ }")]),_._v(" "),v("p",[_._v("return new Map([")]),_._v(" "),v("p",[_._v("[/^guest_[1-4]$/, functionA],")]),_._v(" "),v("p",[_._v("[/^guest_5$/, functionB],")]),_._v(" "),v("p",[_._v("//...")]),_._v(" "),v("p",[_._v("])")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("const onButtonClick = (identity, status) => {")]),_._v(" "),v("p",[_._v("let action = [...actions()].filter(([key, value]) => (key.test("),v("code",[_._v("${identity}_${status}")]),_._v(")))")]),_._v(" "),v("p",[_._v("action.forEach(([key, value]) => value.call(this))")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:")]),_._v(" "),v("blockquote",[v("p",[_._v("const actions = () => {")]),_._v(" "),v("p",[_._v("const functionA = () => { /"),v("em",[_._v("do sth")]),_._v("/ }")]),_._v(" "),v("p",[_._v("const functionB = () => { /"),v("em",[_._v("do sth")]),_._v("/ }")]),_._v(" "),v("p",[_._v("const functionC = () => { /"),v("em",[_._v("send log")]),_._v("/ }")]),_._v(" "),v("p",[_._v("return new Map([")]),_._v(" "),v("p",[_._v("[/^guest_[1-4]$/, functionA],")]),_._v(" "),v("p",[_._v("[/^guest_5$/, functionB],")]),_._v(" "),v("p",[_._v("[/^guest_.*$/, functionC],")]),_._v(" "),v("p",[_._v("//...")]),_._v(" "),v("p",[_._v("])")]),_._v(" "),v("p",[_._v("}")]),_._v(" "),v("p",[_._v("const onButtonClick = (identity, status) => {")]),_._v(" "),v("p",[_._v("let action = [...actions()].filter(([key, value]) => (key.test("),v("code",[_._v("${identity}_${status}")]),_._v(")))")]),_._v(" "),v("p",[_._v("action.forEach(([key, value]) => value.call(this))")]),_._v(" "),v("p",[_._v("}")])]),_._v(" "),v("p",[_._v("也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。")])])}),[],!1,null,null,null);v.default=e.exports}}]);