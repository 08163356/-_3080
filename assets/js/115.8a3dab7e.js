(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{452:function(t,v,_){"use strict";_.r(v);var r=_(7),s=Object(r.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"一、单一职责模式之bridge-桥模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、单一职责模式之bridge-桥模式"}},[t._v("#")]),t._v(" "),v("strong",[t._v("一、单一职责模式之Bridge（桥模式）")])]),t._v(" "),v("p",[v("strong",[t._v("1.概念")]),t._v("：在软件的组织设计中，如果责任划分得不清晰，是的继承得到得结果往往随着需求变化，子类极具膨胀，同时充斥着重复代码，这时候得关键就是划清责任。")]),t._v(" "),v("p",[v("strong",[t._v("2.理解")]),t._v("：使用继承增加功能会使得代码重复量太多。需要将责任划分清楚")]),t._v(" "),v("p",[v("strong",[t._v("3.动机")]),t._v('：由于某些固有的实现逻辑，使得他们具有两个乃至多个维度的变化。产生的问题：如何应对这种"多维度的变化"?如何利用面向对象技术来使得类型可以轻松的沿着两个乃至多个方向变化，而不引入额外复杂度？')]),t._v(" "),v("p",[t._v("如果在不同的平台上支持不同的功能，部分函数需要改变，但是大多数（基本的事务）是不用改变的")]),t._v(" "),v("p",[v("strong",[t._v("4.操作")]),t._v("：将继承转组合，也就是继承的类变成抽象类的指针（即生成指针对象），将编译时装配转换成运行时装配。这样相同的方法只要用指针指向就可以了，需要添加的方法则重新实现再指向对应的方法。同时需要接口隔离，将共有的方法提取出来到一个类中，可变的方法放到另外一个类。")]),t._v(" "),v("p",[t._v("“如果不同的类有同样的字段，向上提（放到父类）”")]),t._v(" "),v("p",[v("strong",[t._v("5.模式定义")]),t._v("：将抽象部分（业务功能）与实现部分（平台实现）芬妮，使他们可以独立地变化。\t\t\t\t\t--《设计模式》 GoF")]),t._v(" "),v("p",[v("strong",[t._v("个人理解")]),t._v("：将平台实现（运行在譬如手机、电脑等不同平台）和具体实现（各平台不同功能）分离")]),t._v(" "),v("p",[v("strong",[t._v("6.要点总结")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度，即“子类化他们”")]),t._v(" "),v("p",[t._v("理解：将指针抽象为桥，连接两边的变化")])]),t._v(" "),v("li",[v("p",[t._v("Bridge模式有时候类似于多个继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化原因），复用性比较差。Bridge模式是比多继承方案更好的解决办法。")])]),t._v(" "),v("li",[v("p",[t._v("Bridge模式的引用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以Bridge的扩展模式")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);