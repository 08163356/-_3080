(window.webpackJsonp=window.webpackJsonp||[]).push([[723],{1065:function(n,t,e){"use strict";e.r(t);var r=e(7),v=Object(r.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("canvas 渲染是一个不断擦除和重绘的过程，一般会配合 requestAnimationFrame 使用，要想让人觉得流畅，就要把每一帧的时间控制在 16ms 以内，当然越少越好，而每一帧主要又包含两个部分：计算和渲染。于是乎要想提高 canvas 的性能，无非就是从这两方面下手：")]),n._v(" "),t("ul",[t("li",[n._v("计算：\n"),t("ul",[t("li",[n._v("减少数据量")]),n._v(" "),t("li",[n._v("加快处理")])])]),n._v(" "),t("li",[n._v("绘制：\n"),t("ul",[t("li",[n._v("尽可能少的绘制")]),n._v(" "),t("li",[n._v("尽可能快的绘制")])])])]),n._v(" "),t("p",[n._v("这是最重要的原则，也是效果最为显著的手段，因为所有的绘制都是有成本的：")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("执行各种逻辑、各种计算")])]),n._v(" "),t("li",[t("p",[n._v("js 调用 canvas api 进行绘制\n")])]),n._v(" "),t("li",[t("p",[n._v("浏览器把渲染后的结果呈现在屏幕上（通常是另一个渲染线程）")])]),n._v(" "),t("li",[t("p",[n._v("...")])])]),n._v(" "),t("p",[n._v("刚才我们说每一帧的时间有 16ms，但实际上是更少的。所以尽可能少的绘制是必须的，下面就来看看基于这个原则的一些实用方法。")]),n._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/post/7135229172409958431",target:"_blank",rel:"noopener noreferrer"}},[n._v("参考文档--较全"),t("OutboundLink")],1)]),n._v(" "),t("p",[t("a",{attrs:{href:"http://fabricjs.com/fabric-object-caching",target:"_blank",rel:"noopener noreferrer"}},[n._v("缓存方案"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);