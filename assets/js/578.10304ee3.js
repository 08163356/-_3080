(window.webpackJsonp=window.webpackJsonp||[]).push([[578],{917:function(e,r,a){"use strict";a.r(r);var t=a(7),_=Object(t.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"_1-什么是浏览器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是浏览器"}},[e._v("#")]),e._v(" 1. 什么是浏览器")]),e._v(" "),r("h1",{attrs:{id:"浏览器是个显示网页服务器或档案系统内的html文件-标准通用标记语言下的一个应用-并让用户与此些文件互动的一种软件。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是个显示网页服务器或档案系统内的html文件-标准通用标记语言下的一个应用-并让用户与此些文件互动的一种软件。"}},[e._v("#")]),e._v(" 浏览器是个显示网页服务器或档案系统内的"),r("a",{attrs:{href:"https://baike.baidu.com/item/HTML%E6%96%87%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTML文件"),r("OutboundLink")],1),e._v("（"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073",target:"_blank",rel:"noopener noreferrer"}},[e._v("标准通用标记语言"),r("OutboundLink")],1),e._v("下的一个应用），并让用户与此些文件互动的一种软件。")]),e._v(" "),r("p",[e._v("世界上主流的浏览器有I"),r("strong",[e._v("E/Edge****，Chrome，Safari，Opera，Firefox。")])]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[r("strong",[e._v("主流浏览器")])]),e._v(" "),r("th",[r("strong",[e._v("内核")])])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("IE -> Edge")]),e._v(" "),r("td",[e._v("trident->EdgeHTML")])]),e._v(" "),r("tr",[r("td",[e._v("Chrome")]),e._v(" "),r("td",[e._v("webkit->blink")])]),e._v(" "),r("tr",[r("td",[e._v("Safari")]),e._v(" "),r("td",[e._v("webkit")])]),e._v(" "),r("tr",[r("td",[e._v("Firefox")]),e._v(" "),r("td",[e._v("Gecko")])])])]),e._v(" "),r("p",[e._v("| Opera          | Presto->blink                                                |\n| "),r("strong",[e._v("主流浏览器")]),e._v(" | "),r("strong",[e._v("js****引擎")]),e._v("                                               |\n| IE -> Edge     | JScript（IE3.0-IE8.0） / Chakra（IE9+之后，查克拉，微软也看火影么..） |\n| Chrome         | V8                                                           |\n| Safari         | Nitro（4-）                                                  |\n| Firefox        | SpiderMonkey（1.0-3.0）/  TraceMonkey（3.5-3.6）/  JaegerMonkey（4.0-） |\n| Opera          | Linear A（4.0-6.1）/  Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |")]),e._v(" "),r("h1",{attrs:{id:"_2-浏览器通用模块和架构介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器通用模块和架构介绍"}},[e._v("#")]),e._v(" 2.浏览器通用模块和架构介绍")]),e._v(" "),r("h2",{attrs:{id:"_2-1-浏览器通用架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-浏览器通用架构"}},[e._v("#")]),e._v(" 2.1 浏览器通用架构")]),e._v(" "),r("p",[e._v("![webkit2](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image002.gif)")]),e._v(" "),r("p",[r("strong",[e._v("操作系统")]),e._v("：这个比较好理解，WebKit可以运行在不同的操作系统上，例如QTWebkit可以运行在Windows或Linux系统，同一个浏览器使用的Webkit也可以依赖不同的操作系统，例如Chromium浏览器支持Windows、Linux、Android等系统；")]),e._v(" "),r("p",[r("strong",[e._v("第三方库")]),e._v("：位于操作系统之上，这些库是WebKit运行的基础，包括图形库、网络库、音视频库等等；")]),e._v(" "),r("p",[r("strong",[e._v("WebCore")]),e._v("：该模块是WebKit加载和渲染网页的基础，是不同浏览器所使用的WebKit中共享的部分，包括HTML解析器、CSS解析器、SVG、布局、渲染树等等；")]),e._v(" "),r("p",[r("strong",[e._v("JavaScript****引擎")]),e._v("：JavaScript解析器，WebKit默认的引擎是JavaScriptCore，Google的Blink替换为自家开发的V8引擎；")]),e._v(" "),r("p",[r("strong",[e._v("WebKit Ports")]),e._v("：WebKit中的移植部分，包括网络栈、音视频解码、硬件加速等模块，这部分对WebKit的功能和性能影响比较大。")]),e._v(" "),r("p",[r("strong",[e._v("WebKit****嵌入式接口")]),e._v("：WebKit对外暴露的接口层，这个接口是提供给浏览器调用的，例如给chromium调用，因为接口与具体的移植也有关系，所以中间会有一个WebKit绑定层；")]),e._v(" "),r("h2",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),r("h2",{attrs:{id:"_2-2渲染引擎webcore"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2渲染引擎webcore"}},[e._v("#")]),e._v(" 2.2渲染引擎WebCore")]),e._v(" "),r("p",[e._v("这个架构图告诉我们WebCore包含了那些功能模块，以及这些模块间的相互关联关系")]),e._v(" "),r("h2",{attrs:{id:"图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[e._v("#")]),e._v(" 图！")]),e._v(" "),r("p",[e._v("2.2.1 webcore 架构图")]),e._v(" "),r("p",[e._v("下面是浏览器渲染解析HTML、CSS、JS的一个流程图：")]),e._v(" "),r("p",[e._v("![webcore2](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image006.jpg)")]),e._v(" "),r("p",[e._v("2.2.2 webcore 渲染流程图")]),e._v(" "),r("p",[e._v("HTML解析后会产生 DOM Tree，解析 CSS 会产生 CSS Rule Tree，Javascript 会通过 DOM API 和 CSS Object Model（CSSOM） API 来操作 DOM Tree 和 CSS Rule Tree。")]),e._v(" "),r("p",[r("strong",[e._v("Dom Tree")])]),e._v(" "),r("p",[e._v("![Dom](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image007.jpg)")]),e._v(" "),r("p",[e._v("从网页 URL 到构建完 DOM 树的过程如图：")]),e._v(" "),r("p",[e._v("![parse](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image009.gif)")]),e._v(" "),r("p",[e._v("CSS Rule Tree：")]),e._v(" "),r("p",[e._v("![css](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image011.jpg)")]),e._v(" "),r("p",[e._v("通过上面的两个数构造的 Style Context Tree：")]),e._v(" "),r("p",[e._v("![style Content](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image013.jpg)")]),e._v(" "),r("p",[e._v("浏览器引擎最后会 通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。这个过程如下：")]),e._v(" "),r("p",[e._v("![rending](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image015.gif)")]),e._v(" "),r("p",[e._v("计算每个 Node 的位置，执行 Layout 过程：")]),e._v(" "),r("p",[e._v("![layout](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image017.jpg)")]),e._v(" "),r("p",[e._v("Compute style 是计算 CSS 样式，Construct frames 是构造显示框架，layout 是定位坐标和大小，各种 position，overflow，z-index 等。这些箭头表示动态修改了 DOM 属性和 CSS 属性会导致 Layout 执行。")]),e._v(" "),r("p",[e._v("完整的渲染流程图：")]),e._v(" "),r("p",[e._v("![ren](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image019.gif)")]),e._v(" "),r("h2",{attrs:{id:"_2-3-loader-和-render"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-loader-和-render"}},[e._v("#")]),e._v(" 2.3 Loader 和 Render")]),e._v(" "),r("p",[e._v("在WebCore中Loader和Render比较重要的模块。其中loader是资源加载模块，是总的入口。URL访问获取资源就是通过loader去进行的。")]),e._v(" "),r("p",[r("strong",[e._v("Loader")]),e._v("：主要作用就是加载资源，有 MainResourceLoader 和 SubResourceLoader。加载的资源有来自网络，本地或者缓存的。Loader 模块本身是平台无关的，只是将需要获得资源的请求传给平台相关的网络模块，接受网络模块返回资源。下面是主要资源的类型：")]),e._v(" "),r("ul",[r("li",[e._v("HTML：页面主文件")]),e._v(" "),r("li",[e._v("JavaScript：单独的文件后者直接在 HTML 代码里")]),e._v(" "),r("li",[e._v("CSS：同 JavaScript 一样可以是单独文件也可以直接写在 HTML 代码里")]),e._v(" "),r("li",[e._v("图片：各种编码图片比如 jpg 和 png")]),e._v(" "),r("li",[e._v("SVG：矢量图片")]),e._v(" "),r("li",[e._v("CSS Shader：为 CSS 带来 3D 图形特性")]),e._v(" "),r("li",[e._v("音频视频：多媒体资源以及视频字幕")]),e._v(" "),r("li",[e._v("字体：自定义的字体")]),e._v(" "),r("li",[e._v("XSL：对 XSLT 语言编写的文件支持")])]),e._v(" "),r("p",[e._v("Loader大致的加载流程示意图：")]),e._v(" "),r("p",[e._v("![loader1](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image021.gif)")]),e._v(" "),r("p",[e._v("![loader2](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image023.jpg)")]),e._v(" "),r("p",[r("strong",[e._v("Render")]),e._v("：它是对DOM树更进一步的描述，其描述的内容主要与布局渲染等CSS相关属性如left、top、width、height、color、font等有关，因为不同的DOM树结点可能会有不同的布局渲染属性，甚至布局时会按照标准动态生成一些匿名节点，所以为了更加方便的描述布局及渲染，WebKit内核又生成一颗Render树来描述DOM树的布局渲染等特性，当然DOM树与Render树不是一一对应，但可以相互关联。")]),e._v(" "),r("p",[e._v("//TODO 本质上就是根据CSS rule 生成render Tree。这里面设计的流程太过复杂，暂时不做深入说明。有兴趣的同事可以参考如下网址：")]),e._v(" "),r("p",[e._v("https://ming1016.github.io/2017/10/11/deeply-analyse-webkit/")]),e._v(" "),r("h1",{attrs:{id:"_3-javascript-引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-javascript-引擎"}},[e._v("#")]),e._v(" 3.Javascript 引擎")]),e._v(" "),r("p",[e._v("JavaScript是一种解释型语言，也就是说，它不需要编译，可以由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。为了提高运行速度，目前的浏览器都将JavaScript进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。")]),e._v(" "),r("p",[e._v("早期，浏览器内部对JavaScript的处理过程如下：")]),e._v(" "),r("p",[e._v("\\1. 读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。")]),e._v(" "),r("p",[e._v("\\2. 对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。")]),e._v(" "),r("p",[e._v("\\3. 使用“翻译器”（translator），将代码转为字节码（bytecode）。")]),e._v(" "),r("p",[e._v("\\4. 使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。")]),e._v(" "),r("p",[e._v("逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。")]),e._v(" "),r("p",[e._v("不同的浏览器有不同的编译策略。有的浏览器只编译最经常用到的部分，比如循环的部分；有的浏览器索性省略了字节码的翻译步骤，直接编译成机器码，比如chrome浏览器的V8引擎。")]),e._v(" "),r("p",[e._v("字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般把虚拟机称为JavaScript引擎。因为JavaScript运行时未必有字节码，所以JavaScript虚拟机并不完全基于字节码，而是部分基于源码，即只要有可能，就通过JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些JavaScript虚拟机：")]),e._v(" "),r("p",[e._v("·     "),r("a",{attrs:{href:"http://en.wikipedia.org/wiki/Chakra_(JScript_engine/)",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chakra"),r("OutboundLink")],1),e._v("(Microsoft Internet Explorer)")]),e._v(" "),r("p",[e._v("·     "),r("a",{attrs:{href:"http://en.wikipedia.org/wiki/WebKit#JavaScriptCore",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nitro/JavaScript Core"),r("OutboundLink")],1),e._v(" (Safari)")]),e._v(" "),r("p",[e._v("·     "),r("a",{attrs:{href:"http://dev.opera.com/articles/view/labs-carakan/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Carakan"),r("OutboundLink")],1),e._v(" (Opera)")]),e._v(" "),r("p",[e._v("·     "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/SpiderMonkey",target:"_blank",rel:"noopener noreferrer"}},[e._v("SpiderMonkey"),r("OutboundLink")],1),e._v(" (Firefox)")]),e._v(" "),r("p",[e._v("·     "),r("a",{attrs:{href:"http://en.wikipedia.org/wiki/V8_(JavaScript_engine/)",target:"_blank",rel:"noopener noreferrer"}},[e._v("V8"),r("OutboundLink")],1),e._v(" (Chrome, Chromium)")]),e._v(" "),r("h2",{attrs:{id:"_3-1-javascript引擎是单线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-javascript引擎是单线程"}},[e._v("#")]),e._v(" 3.1 JavaScript引擎是单线程")]),e._v(" "),r("p",[e._v("浏览器中每个一个窗口都是一个单独的进程。浏览器本身是多线程的，Javascript解释引擎是单线程的。")]),e._v(" "),r("h2",{attrs:{id:"_3-2-任务队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-任务队列"}},[e._v("#")]),e._v(" 3.2 任务队列")]),e._v(" "),r("p",[e._v("js运作在浏览器中，是单线程的，js代码始终在一个线程上执行，此线程被称为js引擎线程， javascript引擎是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。每一段JS程序都可以看做是一个任务。")]),e._v(" "),r("p",[e._v("因为js引擎是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。")]),e._v(" "),r("p",[e._v("JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。")]),e._v(" "),r("p",[e._v('于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在JS引擎上排队执行的任务。异步任务指的是，不进入JS引擎、而进入"任务队列"（task queue）的任务')]),e._v(" "),r("h2",{attrs:{id:"_3-3-event-loop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-event-loop"}},[e._v("#")]),e._v(" 3.3 Event Loop")]),e._v(" "),r("p",[e._v("在JS引擎上的任务，只有前一个任务执行完毕，才能执行后一个任务，当JS引擎中的任务执行完成了，就会去查询异步的任务队列中是否有可以执行的任务，一旦这些异步任务可以执行了，就会将它添加到JS引擎中，以此循环。由于JS引擎从“任务队列”中读取事件的这个过程是不断循环的，所以整个的这种运行机制又称为 Event Loop（事件循环）。")]),e._v(" "),r("h2",{attrs:{id:"_3-4-异步任务队列数据来源"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-异步任务队列数据来源"}},[e._v("#")]),e._v(" 3.4 异步任务队列数据来源")]),e._v(" "),r("p",[e._v("GUI事件触发线程:JavaScript引擎脚本的执行不影响html元素事件的触发,点击、放大、拖拽浏览器或DOM元素，触发线程捕捉对应的回调函数,添加到任务队列末尾。")]),e._v(" "),r("p",[e._v("定时触发线程:：当定时时刻达到的时候，定时线程会把对应的函数添加到任务队列末尾。")]),e._v(" "),r("p",[e._v("HTTP异步请求线程：请求线程执行完毕之后 ，会把对应的函数（success、error）添加任务队列末尾。")]),e._v(" "),r("h2",{attrs:{id:"_3-5-总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-总结"}},[e._v("#")]),e._v(" 3.5 总结")]),e._v(" "),r("p",[e._v("![js](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image025.gif)")]),e._v(" "),r("h1",{attrs:{id:"_4-browser-window的概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-browser-window的概念"}},[e._v("#")]),e._v(" 4. Browser window的概念")]),e._v(" "),r("p",[e._v("Window 表示一个浏览器窗口或者说一个框架。一个页面必然是在一个window上进行显示的，它也是资源访问的入口。我们看到的界面可能不止一个window，它可以是多个window的集合，每一个window都有对应自己的页面内容.同时，一个window 对应到webcore中，会有一个render process对其进行支持。")]),e._v(" "),r("p",[e._v("在window 创建的同时，本质上也完成了对DOM window 对象的创建。所以，在控制台上，可以调用到window顶级对象及其方法，如window.open、window.close()、window.document.body")]),e._v(" "),r("h1",{attrs:{id:"_5-browser-多进程架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-browser-多进程架构"}},[e._v("#")]),e._v(" 5. Browser 多进程架构")]),e._v(" "),r("p",[e._v("之所以要实现多进程架构，主要是为了解决以下三个问题：")]),e._v(" "),r("p",[e._v("1、渲染引擎面对日益复杂的js和css，难免出现崩溃，独立的渲染进程避免整个浏览器的crash；")]),e._v(" "),r("p",[e._v("2、面对日益复杂的web应用，浏览器已经扮演了类操作系统的角色，让各页面隔离使浏览器整体的速度、安全都有保证；")]),e._v(" "),r("p",[e._v("3、多进程是模块独立与松耦合的最大化体现，同时保证了各种扩展策略的简洁易行，比如插件。")]),e._v(" "),r("p",[e._v("![chrome](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image027.jpg)")]),e._v(" "),r("p",[e._v("Browser的设计可以简单认为每个Tab页对应了一个进程，据此可以很清晰地看到Browser中的进程关系：主进程Browser管理整个主框架逻辑，负责UI显示和窗口管理，其中有一个Main Thread作为各RenderProcess和RenderView的Host管理不同Tab的渲染和显示，另一个I/O Thread作为代理，支持Host和Client的通信；每个Tab页为Renderer进程，负责自己页面的处理和渲染，通过IPC和I/O Thread的代理，与Browser进程通信。Renderer进程包含Main Thread和Render Thread两个线程，前者负责通信，后者负责页面渲染和交互。可以看到webkit是被包含进每个Renderer进程中的。")]),e._v(" "),r("p",[e._v("每一个Renderer进程包含一个或多个RenderView对象，同时包含一个全局的RenderProcess对象。RenderProcess管理所有的RenderView，维护Renderer进程的全局状态，同时负责与Browser进程通信。RenderView则表示本进程对应的页面内容或弹出窗口。")]),e._v(" "),r("p",[e._v("每一个RenderProcess在Browser进程中都有一个RenderProcessHost与之对应并通信，一个RenderProcessHost对象代表一个Browser-Renderer的IPC连接。同时每个RenderView与webkit及对应的一个RenderViewHost通信，RenderView与RenderViewHost的通信通过RenderProcess进行。")]),e._v(" "),r("p",[e._v("除了每个tab页一个进程的模型，Browser还支持几种不同的多进程策略：")]),e._v(" "),r("p",[e._v("1、Process-per-site-instance：用户打开一个站点网页，从此网站打开的一系列链接属于一个进程；")]),e._v(" "),r("p",[e._v("2、Process-per-site：一个站点一个进程；")]),e._v(" "),r("p",[e._v("3、Process-per-tab：一个Tab页一个进程；")]),e._v(" "),r("p",[e._v("4、Single process：单进程模式。")]),e._v(" "),r("p",[e._v("chrome浏览器默认采用第一种模型，也可以用命令行切换模式，具体参考："),r("a",{attrs:{href:"http://www.chromium.org/developers/design-documents/process-models",target:"_blank",rel:"noopener noreferrer"}},[e._v("Process Models"),r("OutboundLink")],1),e._v("。另外，Browser中的插件也是以进程的形式运行的。")]),e._v(" "),r("p",[e._v("再来看看多进程加载网页资源架构。在chromium中，所有网络访问在Browser进程中进行，这样做的目的一是有利于全局控制，二是能在不同进程间保持cookie等的session状态。架构图如下所示。")]),e._v(" "),r("p",[e._v("![chrome2](file:///C:\\Users\\luxing3\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image029.jpg)")]),e._v(" "),r("p",[e._v("可以看到资源加载是依赖chromium多进程架构设计的，Renderer进程的ResourceDispatcher与Browser进程的ResourceDispatcherHost通信，通过Browser完成资源加载。chromium通过重新实现webkit中的ResourceHandle来实现这一逻辑。具体参考："),r("a",{attrs:{href:"http://www.chromium.org/developers/design-documents/multi-process-resource-loading",target:"_blank",rel:"noopener noreferrer"}},[e._v("Multi-process Resource Loading"),r("OutboundLink")],1),e._v("。")])])}),[],!1,null,null,null);r.default=_.exports}}]);