(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{464:function(t,o,v){"use strict";v.r(o);var _=v(7),r=Object(_.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h3",{attrs:{id:"一、单一职责模式之decorator-装饰模式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#一、单一职责模式之decorator-装饰模式"}},[t._v("#")]),t._v(" "),o("strong",[t._v("一、单一职责模式之Decorator（装饰模式）")])]),t._v(" "),o("p",[t._v("在软件组件的设计中,如果责任划分的不清晰，使用承得到的果是随着需求的变化,子类急剧膨胀,同时充斥着重代码，这时候的关键是划清责任。")]),t._v(" "),o("p",[o("strong",[t._v("动机")])]),t._v(" "),o("p",[t._v("在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由\n于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并\n且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功\n能的组合）会导致更多子类的膨胀。")]),t._v(" "),o("p",[o("strong",[t._v("解决问题")])]),t._v(" "),o("p",[t._v("如何使“对象功能的扩展”能够根据需要来动态地实现？")]),t._v(" "),o("p",[t._v("同时避免 “扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变 化”所导致的影响将为最低？\n")]),t._v(" "),o("p",[t._v("将编译时编译变成装配时编译（运行时编译）")]),t._v(" "),o("p",[t._v("就是在固有的类基础上进行拓展和改进（装饰）")]),t._v(" "),o("p",[o("strong",[t._v("定义")])]),t._v(" "),o("p",[t._v("动态（组合）的给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码&减少重复个数）")]),t._v(" "),o("p",[o("strong",[t._v("要点总结")])]),t._v(" "),o("ul",[o("li",[t._v("通过采用组合而非继承的手法，Decorator模式实现了在运行时动态拓展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生的问题”")]),t._v(" "),o("li",[t._v("Decorator类在接口上表现为 is-a Component的继承关系，即"),o("strong",[t._v("Decorator类继承了Component类所具有的接口。但在是线上又表现为has-a Component的组合关系")]),t._v("，即Decorator类又使用了另外一个Conponent类。")]),t._v(" "),o("li",[t._v("Decorator模式的目的并非接解决“多子类衍生的多继承问题”，Decorator模式应用的要点在于解决“主题类在多个方向上扩展功能”--是为“装饰”的含义。")])]),t._v(" "),o("h3",{attrs:{id:"二、散装问题知识点"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#二、散装问题知识点"}},[t._v("#")]),t._v(" "),o("strong",[t._v("二、散装问题知识点")])]),t._v(" "),o("p",[t._v("1.文件流和内存流不是一个东西吗？")]),t._v(" "),o("p",[t._v("2.继承的命名方式，子类的继承在父类名字前面加上操作子类的子类以此类推。")]),t._v(" "),o("p",[t._v("3.重构的时候需要尽力消除重复的代码")]),t._v(" "),o("p",[t._v("4.设计原则：组合优于继承")]),t._v(" "),o("p",[t._v("5.构造器的作用是什么呢？")])])}),[],!1,null,null,null);o.default=r.exports}}]);