(window.webpackJsonp=window.webpackJsonp||[]).push([[345],{684:function(e,t,r){"use strict";r.r(t);var o=r(7),i=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v('const person = { name: "Lydia Hallie", age: 21 } [...person] // ["Lydia Hallie", 21]')]),e._v(" "),t("p",[e._v("难度： 更新时间：2023-03-04选项（单选）：A、不需要，对象默认就是可迭代的B、"),t("em",[t("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" { for (let x in this) yield this[x] }C、")]),t("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" { for (let x in this) yield* Object.values(this) }D、*"),t("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" { for (let x in this) yield this }答案及解析：正确答案：B")]),e._v(" "),t("p",[e._v("对象默认并不是可迭代的。")]),e._v(" "),t("p",[e._v("如果迭代规则被定义，则一个对象是可迭代的（An iterable is an iterable if the iterator protocol is present）。")]),e._v(" "),t("p",[e._v("我们可以通过添加迭代器symbol [Symbol.iterator] 来定义迭代规则，其返回一个 generator 对象，比如说构建一个 generator 函数 *"),t("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" {}。")]),e._v(" "),t("p",[e._v('如果我们想要返回数组 ["Lydia Hallie", 21]: yield* Object.values(this)，这个 generator 函数一定要 yield 对象 person 的 values 。')]),e._v(" "),t("p",[e._v("另外，本题还需要注意的一个点：")]),e._v(" "),t("p",[e._v("yield 关键字用来暂停和恢复一个生成器函数（function*）")]),e._v(" "),t("p",[e._v("yield* 表达式用于委托给另一个 generator 或可迭代对象。")]),e._v(" "),t("p",[e._v("const person = { name: 'lzh', age: 21 } // 方法一 person[Symbol.iterator] = function* () { yield* Object.values(this) } // 方法二 person[Symbol.iterator] = function* () { for (let x in this) { yield this[x] } } console.log([...person]); //['lzh', 21]")])])}),[],!1,null,null,null);t.default=i.exports}}]);