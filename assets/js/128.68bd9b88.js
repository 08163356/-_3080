(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{465:function(_,t,a){"use strict";a.r(t);var v=a(7),r=Object(v.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h3",{attrs:{id:"一、学前思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、学前思考"}},[_._v("#")]),_._v(" 一、学前思考")]),_._v(" "),t("p",[_._v("1.什么是中介者？")]),_._v(" "),t("p",[_._v("猜想：找工作，找房子那样的中介吗？提供一个平台让两方进行交互？")]),_._v(" "),t("p",[_._v("2.中介者常用在什么场景下？")]),_._v(" "),t("h3",{attrs:{id:"二、接口隔离模式之mediator-中介者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、接口隔离模式之mediator-中介者"}},[_._v("#")]),_._v(" 二、接口隔离模式之Mediator（中介者）")]),_._v(" "),t("p",[_._v("在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来相互紧密关联的接口是一种常见的解决方案，")]),_._v(" "),t("h4",{attrs:{id:"_1-动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-动机"}},[_._v("#")]),_._v(" 1.动机")]),_._v(" "),t("p",[_._v("在软件构建过程中，经常会出现"),t("u",[_._v("多个对象")]),_._v("互相关联交互的情况，对象之间常常会维持一种"),t("u",[_._v("复杂")]),_._v("的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断变化。")]),_._v(" "),t("p",[_._v("（理解：对象间采用引用，一旦某个对象发生改变，会牵一发动全身，所有地方都要改变，无法灵活的应对变化）")]),_._v(" "),t("p",[_._v("在这种情况下，我们可使用一个“中介对象”来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。")]),_._v(" "),t("h4",{attrs:{id:"_2-模式定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-模式定义"}},[_._v("#")]),_._v(" 2.模式定义")]),_._v(" "),t("p",[_._v("用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖->运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变他们之间的交互。")]),_._v(" "),t("p",[_._v("（理解：也就是把引用集中起来管理?像工厂方法一样将新建对象集中起来管理？）")]),_._v(" "),t("p",[_._v("3.结构")]),_._v(" "),t("p",[_._v("（结构图）")]),_._v(" "),t("p",[_._v("有点像路由器")]),_._v(" "),t("p",[_._v("对象之间不直接依赖，而是和一个中介产生双向依赖，更好的抵御变化。facede使解决系统内和系统外之间的一个隔离，而中介者模式使解决系统内对象之间的隔离问题")]),_._v(" "),t("h4",{attrs:{id:"_3-要点总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-要点总结"}},[_._v("#")]),_._v(" 3.要点总结")]),_._v(" "),t("ul",[t("li",[_._v("将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的逻辑控制进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统维护，抵御了可能的变化。")]),_._v(" "),t("li",[_._v("随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。")]),_._v(" "),t("li",[_._v("Facade模式使解耦系统间（单向）的对象关联关系；Mediator模式是解耦系统内各个对象间（双向）的关联关系。")])]),_._v(" "),t("h3",{attrs:{id:"三、散装知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、散装知识点"}},[_._v("#")]),_._v(" 三、散装知识点")]),_._v(" "),t("p",[_._v("1.依赖倒置原则就是将编译时依赖->运行时依赖，中介者使依赖倒置的一个扩充")])])}),[],!1,null,null,null);t.default=r.exports}}]);