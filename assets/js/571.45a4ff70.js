(window.webpackJsonp=window.webpackJsonp||[]).push([[571],{909:function(s,n,a){"use strict";a.r(n);var e=a(7),t=Object(e.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("p",[s._v("问题：")]),s._v(" "),n("p",[s._v("1.vite打包的速度很慢为啥")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vite是一个基于ESM的构建工具，它使用了现代浏览器的原生ES模块解析器，可以实现快速的开发和构建。但是，Vite打包速度慢的问题可能是由于以下原因导致的：\n\n1. 依赖库过多：如果项目中依赖的库过多，会导致打包速度变慢。可以通过减少依赖库或者使用Tree Shaking等技术来优化打包速度。\n\n2. 配置不当：Vite的配置文件中有很多选项，如果配置不当，也会导致打包速度变慢。可以针对具体的应用场景进行优化配置。\n\x3c!-- more --\x3e\n\n3. 代码质量问题：如果代码质量不佳，如过多的嵌套、重复代码等，也会导致打包速度变慢。可以通过代码重构等方式来优化代码质量。\n\n4. 硬件设备问题：如果硬件设备性能较低，也会导致打包速度变慢。可以考虑升级硬件设备或者使用云服务等方式来提高打包速度。\n\n为了优化Vite的打包速度，可以尝试以下解决办法：\n\n1. 减少依赖库：尽量减少依赖库的数量和大小，可以使用Tree Shaking等技术来优化依赖库。\n\n2. 优化配置文件：根据应用场景和需求进行优化配置，如关闭不必要的选项、使用合适的插件等。\n\n3. 优化代码质量：优化代码质量，如减少嵌套、删除重复代码等，可以提高打包速度。\n\n4. 使用缓存：使用缓存可以避免重复打包，从而提高打包速度。\n\n5. 升级硬件设备：如果硬件设备性能较低，可以考虑升级硬件设备或者使用云服务等方式来提高打包速度。\n\n需要注意的是，Vite打包速度慢的问题可能是由多种因素导致的，需要根据具体的应用场景和需求进行评估和优化，不能一概而论。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br")])]),n("p",[s._v("2.前端修改一个地方后往往需要很长的时间才能在网页中显示出来")]),s._v(" "),n("p",[s._v("引申问题：")]),s._v(" "),n("p",[s._v("vite如何使用tree shaking进行打包优化")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Tree-shaking (摇树优化）Tree-shaking的本质是消除无用的js代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为DCE（dead code elimination）。 Tree-shaking 是 DCE 的一种新的实现，Javascript同传统的编程语言不同的是，javascript绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对javascript来说更有意义。 Tree-shaking 和传统的 DCE的方法又不太一样，传统的DCE 消灭不可能执行的代码，而Tree-shaking 更关注于消除没有用到的代码。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])])])}),[],!1,null,null,null);n.default=t.exports}}]);