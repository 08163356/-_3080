(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{461:function(t,a,_){"use strict";_.r(a);var v=_(7),r=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"一、学前思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、学前思考"}},[t._v("#")]),t._v(" 一、学前思考")]),t._v(" "),a("p",[t._v("1.什么是适配器？")]),t._v(" "),a("blockquote",[a("p",[t._v("适配器是一个接口"),a("a",{attrs:{href:"https://baike.baidu.com/item/%E8%BD%AC%E6%8D%A2%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("转换器"),a("OutboundLink")],1),t._v("，它可以是一个独立的硬件接口设备，允许硬件或电子接口与其它硬件或电子接口相连，也可以是信息接口")])]),t._v(" "),a("p",[t._v("理解：")]),t._v(" "),a("p",[t._v("1）笔记本电源就是一个适配器，计算机需要的电源是恒定的，但是插座不一定（这个层面抽象出来就是将变化的东西通过适配器转换成恒定的事物）")]),t._v(" "),a("p",[t._v("2）已完成的项目有需求变动更改接口很可能牵一发动全身，这时候可以使用适配器。")]),t._v(" "),a("p",[t._v("3）电脑投影（HDML和VGA）也是适配器")]),t._v(" "),a("p",[t._v("2.适配器有哪些种类？")]),t._v(" "),a("h3",{attrs:{id:"二、接口隔离模式之adapter-适配器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、接口隔离模式之adapter-适配器模式"}},[t._v("#")]),t._v(" 二、接口隔离模式之Adapter（适配器模式）")]),t._v(" "),a("p",[t._v("在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来相互紧密关联的接口是一种常见的解决方案。")]),t._v(" "),a("h4",{attrs:{id:"_1-动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-动机"}},[t._v("#")]),t._v(" 1.动机")]),t._v(" "),a("p",[t._v("在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。")]),t._v(" "),a("p",[t._v("如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？")]),t._v(" "),a("h4",{attrs:{id:"_2-结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-结构"}},[t._v("#")]),t._v(" 2.结构")]),t._v(" "),a("p",[t._v("（类图）")]),t._v(" "),a("p",[a("strong",[t._v("关联（Association）")]),t._v("：实线箭头表示。 是类与类之间的联结，它使一个类知道另一个类的属性和方法 ； 关联可以是双向的，也可以是单向的 ； 双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头 ； 在 Java 或 c++ 中，关联关系是通过使用成员变量来实现的 ； 元素间的结构化关系，是一种弱关系，被关联的元素间通常可以被独立的考虑")]),t._v(" "),a("p",[a("strong",[t._v("泛化（Generalization）")]),t._v("：带空心箭头的实线。 表示一个更泛化的元素和一个更具体的元素之间的关系； 泛化关系表示类与类之间的继承关系，接口与接口之间的继承关系；  在Java中，用"),a("em",[t._v("extends")]),t._v("关键字来直接表示这种关系 ； 通常所说的继承（特殊个体 is kind of 一般个体）关系 ；")]),t._v(" "),a("h4",{attrs:{id:"_3-模式定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-模式定义"}},[t._v("#")]),t._v(" 3.模式定义")]),t._v(" "),a("p",[t._v("将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。")]),t._v(" "),a("h4",{attrs:{id:"_4-要点总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-要点总结"}},[t._v("#")]),t._v(" 4.要点总结")]),t._v(" "),a("ul",[a("li",[t._v("Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用，类库迁移等方面非常有用")]),t._v(" "),a("li",[t._v("GOF23定义了两种Adapter模式的实现结构：对象适配器和类适配器（用的相当少，只有坏处没有好处）。但类适配器采用了“多继承”的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。")]),t._v(" "),a("li",[t._v("Adapter模式可以实现的非常灵活，不必拘泥于Gof23定义中的两种结构。例如，完全可以将Adapter模式中的“现存现象”作为新的接口方法参数，来达到适配的目的。")])]),t._v(" "),a("h3",{attrs:{id:"三、散装知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、散装知识点"}},[t._v("#")]),t._v(" 三、散装知识点")]),t._v(" "),a("p",[t._v("1.类图里面的符号都代表什么意思呢？"),a("a",{attrs:{href:"https://www.cnblogs.com/duanxz/archive/2012/06/13/2547801.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("UML类图符号解释"),a("OutboundLink")],1),t._v("，看到一个解释一个吧，不系统的学习")]),t._v(" "),a("p",[t._v("2.组合关系是什么意思？")]),t._v(" "),a("blockquote",[a("p",[t._v("组合（Composition）：组合是聚合关系的变种，表示元素间更强的组合关系。如果是组合关系，如果整体被破坏则个体一定会被破坏，而聚合的个体则可能是被多个整体所共享的，不一定会随着某个整体的破坏而被破坏。uml中用带实心菱形头的实线表示Composition关系，菱形头指向整体。")])]),t._v(" "),a("p",[t._v("3.C++STL中的栈和队列都是list的适配器，中间使用了deque实现了一个接口转换成了另外的接口（老接口转换成新接口）")]),t._v(" "),a("p",[t._v("4.设计模式不能生搬硬套，不能照本宣科")])])}),[],!1,null,null,null);a.default=r.exports}}]);