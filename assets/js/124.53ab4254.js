(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{462:function(t,a,_){"use strict";_.r(a);var v=_(7),r=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"一、学前思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、学前思考"}},[t._v("#")]),t._v(" 一、学前思考")]),t._v(" "),a("p",[t._v("1.什么是构造器?")]),t._v(" "),a("p",[t._v("构造器可以用public、priviate、protected这样的关键词修饰。没有返回值")]),t._v(" "),a("blockquote",[a("p",[t._v("构造方法是一种特殊的方法，与一般的方法不同是：\n1.构造方法的名字必须与定义他的类名完全相同，没有返回类型，甚至连void也没有。\n2.构造方法的调用是在创建一个对象时使用new操作进行的。构造方法的作用是初始化对象。\n3.不能被static、final、synchronized、abstract和native修饰。\n构造方法不能被子类继承。 构造方法可以被重载。\n没有参数的构造方法称为默认构造方法，\n与一般的方法一样，构造方法可以进行任何活动，但是经常将他设计为进行各种初始化活动，\n比如初始化对象的属性。\n在Java中,任何变量在被使用前都必须先设置初值.\nJava提供了为类的成员变量赋初值的专门功能:构造方法(constructor)构造方法是一种特殊的成员方法,\n"),t._v("\n它的特殊性反映在如下几个方面:\n(1)构造方法名与类名相同.\n(2)构造方法不返回任何值,也没有返回类型.\n(3)每个类可以有零个或多个构造方法.\n(4)构造方法在创建对象时自动执行,一般不能显式地直接调用")])]),t._v(" "),a("p",[t._v("2.STL以及泛型编程中的迭代器是什么？")]),t._v(" "),a("p",[t._v("泛型编程是使用基于模板的迭代器")]),t._v(" "),a("p",[t._v("泛型编程有很多种迭代器。有五种迭代器。很少用面向对象的迭代器")]),t._v(" "),a("p",[t._v("通过接口的方式去隔离算法和容器之间的变化")]),t._v(" "),a("h3",{attrs:{id:"二、数据结构模式之iterator-构造器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、数据结构模式之iterator-构造器模式"}},[t._v("#")]),t._v(" 二、数据结构模式之Iterator（构造器模式）")]),t._v(" "),a("p",[t._v("常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定的数据结构都封装在内部，在外部提供统一的接口，来实现这些与特定数据结构无关的访问。")]),t._v(" "),a("h5",{attrs:{id:"_1-动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-动机"}},[t._v("#")]),t._v(" 1.动机")]),t._v(" "),a("p",[t._v("在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历“也为”同一种算法在多种集合对象上进行操作“提供了可能")]),t._v(" "),a("p",[t._v("使用面向对象技术将这种遍历机制抽象成为”迭代器对象“为”应对变化种的集合对象“提供了一种优雅的方式。")]),t._v(" "),a("h5",{attrs:{id:"_2-模式定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-模式定义"}},[t._v("#")]),t._v(" 2.模式定义")]),t._v(" "),a("p",[t._v("提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。")]),t._v(" "),a("h5",{attrs:{id:"_3-结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-结构"}},[t._v("#")]),t._v(" 3.结构")]),t._v(" "),a("h5",{attrs:{id:"_4-要点总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-要点总结"}},[t._v("#")]),t._v(" 4.要点总结")]),t._v(" "),a("p",[t._v("迭代抽象：访问一个聚合对象的内容而无需暴露他的内部表示")]),t._v(" "),a("p",[t._v("迭代多态：为便利不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作")]),t._v(" "),a("p",[t._v("迭代器的健壮性考虑：遍历的同时更该迭代器所在的集合结构，会导致问题。")]),t._v(" "),a("h3",{attrs:{id:"三、散装知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、散装知识点"}},[t._v("#")]),t._v(" 三、散装知识点")]),t._v(" "),a("p",[t._v("1.这个模式在C++中已经过时了。迭代器的设计是纯面向对象思想的。虚函数调用有调用成本，有二次指针的间接调用。")]),t._v(" "),a("p",[t._v("2.面向对象的核心是多态。模板也是一种多态技术（编译时多态）。虚函数是运行时多态，运行时多态性能比编译时多态低。")]),t._v(" "),a("p",[t._v("3.本文针对C++，在其他语言种这种方法有很大的用处。（比如JAVA，C#）")]),t._v(" "),a("p",[t._v("4.随着技术发展很多设计模式会过时，但是思想不会过时")])])}),[],!1,null,null,null);a.default=r.exports}}]);